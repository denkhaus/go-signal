package gosignal

import (
	"fmt"
	"os"
	"os/signal"
)

type SignalHandlerFunc func(os.Signal)

///////////////////////////////////////////////////////////////////////////////////////////
// SignalHandler
///////////////////////////////////////////////////////////////////////////////////////////
type SignalHandler struct {
	intChan chan os.Signal
	addChan chan SignalHandlerFunc
	intCbs  []SignalHandlerFunc
}

///////////////////////////////////////////////////////////////////////////////////////////
// AddHandler
///////////////////////////////////////////////////////////////////////////////////////////
func (s *SignalHandler) AddHandler(handler SignalHandlerFunc) {
	s.addChan <- handler
}

///////////////////////////////////////////////////////////////////////////////////////////
// maintainLoop
///////////////////////////////////////////////////////////////////////////////////////////
func (s *SignalHandler) maintainLoop() {
	signal.Notify(s.intChan, os.Interrupt)

	for {
		select {
		case signal := <-s.intChan:
			fmt.Println("Received SIGINT (Ctrl+C).  Shutting down...")
			for _, callback := range s.intCbs {
				callback(signal)
			}

		case handler := <-s.addChan:
			s.intCbs = append(s.intCbs, handler)
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////
// NewSignalHandler
///////////////////////////////////////////////////////////////////////////////////////////
func NewSignalHandler() *SignalHandler {

	h := &SignalHandler{}
	h.intChan = make(chan os.Signal, 1)
	h.addChan = make(chan SignalHandlerFunc)

	go h.maintainLoop()
	return h
}
